<!DOCTYPE html>
<html>

<title>Blog</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<style>
body,h1,h2,h3,h4,h5,ol,li {font-family: "Arial", sans-serif}
.container {
  display: flex;
  justify-content: center;
}
.center {
  width: 800px;
}
img {
   height: auto;
   width:40%;
}
</style>

<body stylstclass="w3-light-grey">
<!-- w3-content defines a container for fixed size centered content, 
and is wrapped around the whole page content, except for the footer in this example -->
<div class="w3-content" style="max-width:1400px;">

<!-- Header -->
<header class="w3-container w3-center w3-padding-32"> 
  <center> <h1><b>State Machine Replication (SMR)</b></h1> </center> 
</header>

<!-- Grid -->
<div class="w3-row">

<!-- Blog entries -->
<div class="container" class="w3-col l8 s12">
  <!-- Blog entry -->
  <div class="w3-card-4 w3-margin w3-white" >

<div class="w3-container"><p style="color:black;font-size:20px;">

  Distributed system is structured in terms of clients and services. Each service forms servers and exports operations that clients invoke by making requests. Multiple servers that fail independently must be used to keep system able to tolerate the failure. Usually, replicas of a single server are executed on separate processors of a distributed system, and protocols are used to coordinate client interactions with these replicas. Using a single node is the easiest way for implementing such services but the node will become the only fault-tolerant node. This level of fault tolerance is weak and has no benefits. The system needs multiple nodes to tolerate the faults and services keep responding to the honest users. 

</p></div>

<div class="w3-container"><p style="color:black;font-size:20px;">

  State machine replication (SMR) is a technique that consists of state variables, which implement its state, and commands, which transform its state for implementing consistent fault-tolerant services [3]. Each command is implemented by a deterministic program in an atomic fashion. SMR is an abstract black box that has an initial state which can be converted into a new state after receiving an input according to the corresponding transition function. This technique manages and controls when commands are distributed by the clients and collecting replies from all replicas. SMR increases the system performance and capacity by providing more resources to the service or provides fault-tolerance by providing redundancy to the system. The requests are processed by a state machine one at a time in order to be consistent. When the client submitted the request to a given state machine, it processed in the order that it was issued.

</p></div>

<div class="w3-container"><p style="color:black;font-size:20px;">

  In SMR fault tolerance, the smallest replication group is four nodes for tolerating byzantine failure. Byzantine problems can be random, malicious, and clever attacks. Using 2F+1 copy, and non-encrypted hash can deal with all non-malicious byzantine problems but a malicious attack requires encrypted transmission using a digital signature. Otherwise, the number of non-encrypted transmission copies in this case requires 3F+1. Generally, a system supports F fault tolerance, then you must use 3F+1 copy.

</p></div>


<div class="w3-container"><p style="color:black;font-size:20px;">

  The theoretical basis of SMR is when each node in the cluster running the same deterministic state machine S, and all state machines are initially in the same initial state denoted as state_0 , then these state machines are given the same input sequence: {input_1, input_2, input_3, input_4, ..., input_n }. These state machines must go through the same state transition path: state_0 -> state_1 -> state_2 -> ... -> state_n. Finally, reaching the same state state_n and generating the same output sequence at the same time {output_1(state_1), output_2(state_2), output_3(state_3 ),..., output_n(state_n)}.

</p></div>

<div class="w3-container"><p style="color:black;font-size:20px;">

  Byzantine fault-tolerant SMR protocols usually consider the existence of authenticated communication channels, which can only be implemented if either a Public-key infrastructure is available for supporting the use of asymmetric cryptography for message signatures or the existence of shared secrets between each pair of processes for enabling the use of Message Authentication Codes (MAC). In both cases, it is always assumed that there exists a collision-resistant hash function for implementing these primitives and, additionally, a symmetric or asymmetric cryptographic algorithm.


</p></div>

<div class="w3-container"><p style="color:black;font-size:20px;">
    <h4>References</h4>
    <footer>
        [1] The State Machine Approach: A Tutorial <cite><a href="https://www.cs.cornell.edu/fbs/publications/ibmFault.sm.pdf">Paper</a></cite> by Fred B. Schneider.
    </footer>
    <footer>
        [2] The State Machine Replication <cite><a href="https://en.wikipedia.org/wiki/State_machine_replication">Wikipedia</a></cite> by Wikipedia.
    </footer>
        <footer>
        [3] A Guided Tour on the Theory and Practice of State Machine Replication <cite><a href="http://www.di.fc.ul.pt/~bessani/publications/tutorial-smr.pdf ">Chapter 4</a></cite> by Alysson Neves Bessani.
    </footer>
</p></div>

  </div>
  <hr>

<!-- END BLOG ENTRIES -->
</div>



<!-- END GRID -->
</div><br>

<!-- END w3-content -->
</div>

<!-- Footer -->
<footer class="w3-container w3-dark-grey w3-padding-32 w3-margin-top">

  <center>
    <a href="http://www.salemmoh.com/MyBlog/Blog.html" class="w3-button w3-padding-large w3-white w3-border" class="w3-button w3-black w3-padding-large w3-margin-bottom">Main Blog</a>
    </button>
  </center>

</footer>

</body>
</html>
